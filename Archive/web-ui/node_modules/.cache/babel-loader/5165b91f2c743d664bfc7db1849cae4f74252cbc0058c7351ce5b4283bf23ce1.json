{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport useLazyRef from '@mui/utils/useLazyRef';\nimport { GRID_DETAIL_PANEL_TOGGLE_FIELD } from \"../../../internals/constants.js\";\nimport { gridVisibleColumnDefinitionsSelector } from \"../columns/gridColumnsSelector.js\";\nimport { useGridVisibleRows } from \"../../utils/useGridVisibleRows.js\";\nimport { gridRenderContextSelector } from \"../virtualization/gridVirtualizationSelectors.js\";\nimport { useGridSelector } from \"../../utils/useGridSelector.js\";\nimport { gridRowTreeSelector } from \"./gridRowsSelector.js\";\nimport { getUnprocessedRange, isRowRangeUpdated, isRowContextInitialized, getCellValue } from \"./gridRowSpanningUtils.js\";\nimport { GRID_CHECKBOX_SELECTION_FIELD } from \"../../../colDef/gridCheckboxSelectionColDef.js\";\nconst EMPTY_STATE = {\n  spannedCells: {},\n  hiddenCells: {},\n  hiddenCellOriginMap: {}\n};\nconst EMPTY_RANGE = {\n  firstRowIndex: 0,\n  lastRowIndex: 0\n};\nconst skippedFields = new Set([GRID_CHECKBOX_SELECTION_FIELD, '__reorder__', GRID_DETAIL_PANEL_TOGGLE_FIELD]);\n/**\n * Default number of rows to process during state initialization to avoid flickering.\n * Number `20` is arbitrarily chosen to be large enough to cover most of the cases without\n * compromising performance.\n */\nconst DEFAULT_ROWS_TO_PROCESS = 20;\nconst computeRowSpanningState = (apiRef, colDefs, visibleRows, range, rangeToProcess, resetState, processedRange) => {\n  const spannedCells = resetState ? {} : _extends({}, apiRef.current.state.rowSpanning.spannedCells);\n  const hiddenCells = resetState ? {} : _extends({}, apiRef.current.state.rowSpanning.hiddenCells);\n  const hiddenCellOriginMap = resetState ? {} : _extends({}, apiRef.current.state.rowSpanning.hiddenCellOriginMap);\n  if (resetState) {\n    processedRange = EMPTY_RANGE;\n  }\n  colDefs.forEach(colDef => {\n    if (skippedFields.has(colDef.field)) {\n      return;\n    }\n    for (let index = rangeToProcess.firstRowIndex; index < rangeToProcess.lastRowIndex; index += 1) {\n      var _hiddenCells$row$id;\n      const row = visibleRows[index];\n      if ((_hiddenCells$row$id = hiddenCells[row.id]) !== null && _hiddenCells$row$id !== void 0 && _hiddenCells$row$id[colDef.field]) {\n        continue;\n      }\n      const cellValue = getCellValue(row.model, colDef, apiRef);\n      if (cellValue == null) {\n        continue;\n      }\n      let spannedRowId = row.id;\n      let spannedRowIndex = index;\n      let rowSpan = 0;\n\n      // For first index, also scan in the previous rows to handle the reset state case e.g by sorting\n      const backwardsHiddenCells = [];\n      if (index === rangeToProcess.firstRowIndex) {\n        let prevIndex = index - 1;\n        const prevRowEntry = visibleRows[prevIndex];\n        while (prevIndex >= range.firstRowIndex && getCellValue(prevRowEntry.model, colDef, apiRef) === cellValue) {\n          const currentRow = visibleRows[prevIndex + 1];\n          if (hiddenCells[currentRow.id]) {\n            hiddenCells[currentRow.id][colDef.field] = true;\n          } else {\n            hiddenCells[currentRow.id] = {\n              [colDef.field]: true\n            };\n          }\n          backwardsHiddenCells.push(index);\n          rowSpan += 1;\n          spannedRowId = prevRowEntry.id;\n          spannedRowIndex = prevIndex;\n          prevIndex -= 1;\n        }\n      }\n      backwardsHiddenCells.forEach(hiddenCellIndex => {\n        if (hiddenCellOriginMap[hiddenCellIndex]) {\n          hiddenCellOriginMap[hiddenCellIndex][colDef.field] = spannedRowIndex;\n        } else {\n          hiddenCellOriginMap[hiddenCellIndex] = {\n            [colDef.field]: spannedRowIndex\n          };\n        }\n      });\n\n      // Scan the next rows\n      let relativeIndex = index + 1;\n      while (relativeIndex <= range.lastRowIndex && visibleRows[relativeIndex] && getCellValue(visibleRows[relativeIndex].model, colDef, apiRef) === cellValue) {\n        const currentRow = visibleRows[relativeIndex];\n        if (hiddenCells[currentRow.id]) {\n          hiddenCells[currentRow.id][colDef.field] = true;\n        } else {\n          hiddenCells[currentRow.id] = {\n            [colDef.field]: true\n          };\n        }\n        if (hiddenCellOriginMap[relativeIndex]) {\n          hiddenCellOriginMap[relativeIndex][colDef.field] = spannedRowIndex;\n        } else {\n          hiddenCellOriginMap[relativeIndex] = {\n            [colDef.field]: spannedRowIndex\n          };\n        }\n        relativeIndex += 1;\n        rowSpan += 1;\n      }\n      if (rowSpan > 0) {\n        if (spannedCells[spannedRowId]) {\n          spannedCells[spannedRowId][colDef.field] = rowSpan + 1;\n        } else {\n          spannedCells[spannedRowId] = {\n            [colDef.field]: rowSpan + 1\n          };\n        }\n      }\n    }\n    processedRange = {\n      firstRowIndex: Math.min(processedRange.firstRowIndex, rangeToProcess.firstRowIndex),\n      lastRowIndex: Math.max(processedRange.lastRowIndex, rangeToProcess.lastRowIndex)\n    };\n  });\n  return {\n    spannedCells,\n    hiddenCells,\n    hiddenCellOriginMap,\n    processedRange\n  };\n};\n\n/**\n * @requires columnsStateInitializer (method) - should be initialized before\n * @requires rowsStateInitializer (method) - should be initialized before\n * @requires filterStateInitializer (method) - should be initialized before\n */\nexport const rowSpanningStateInitializer = (state, props, apiRef) => {\n  if (props.unstable_rowSpanning) {\n    var _state$filter$filterM;\n    const rowIds = state.rows.dataRowIds || [];\n    const orderedFields = state.columns.orderedFields || [];\n    const dataRowIdToModelLookup = state.rows.dataRowIdToModelLookup;\n    const columnsLookup = state.columns.lookup;\n    const isFilteringPending = Boolean(state.filter.filterModel.items.length) || Boolean((_state$filter$filterM = state.filter.filterModel.quickFilterValues) === null || _state$filter$filterM === void 0 ? void 0 : _state$filter$filterM.length);\n    if (!rowIds.length || !orderedFields.length || !dataRowIdToModelLookup || !columnsLookup || isFilteringPending) {\n      return _extends({}, state, {\n        rowSpanning: EMPTY_STATE\n      });\n    }\n    const rangeToProcess = {\n      firstRowIndex: 0,\n      lastRowIndex: Math.min(DEFAULT_ROWS_TO_PROCESS, Math.max(rowIds.length, 0))\n    };\n    const rows = rowIds.map(id => ({\n      id,\n      model: dataRowIdToModelLookup[id]\n    }));\n    const colDefs = orderedFields.map(field => columnsLookup[field]);\n    const {\n      spannedCells,\n      hiddenCells,\n      hiddenCellOriginMap\n    } = computeRowSpanningState(apiRef, colDefs, rows, rangeToProcess, rangeToProcess, true, EMPTY_RANGE);\n    return _extends({}, state, {\n      rowSpanning: {\n        spannedCells,\n        hiddenCells,\n        hiddenCellOriginMap\n      }\n    });\n  }\n  return _extends({}, state, {\n    rowSpanning: EMPTY_STATE\n  });\n};\nexport const useGridRowSpanning = (apiRef, props) => {\n  const {\n    range,\n    rows: visibleRows\n  } = useGridVisibleRows(apiRef, props);\n  const renderContext = useGridSelector(apiRef, gridRenderContextSelector);\n  const colDefs = useGridSelector(apiRef, gridVisibleColumnDefinitionsSelector);\n  const tree = useGridSelector(apiRef, gridRowTreeSelector);\n  const processedRange = useLazyRef(() => {\n    return Object.keys(apiRef.current.state.rowSpanning.spannedCells).length > 0 ? {\n      firstRowIndex: 0,\n      lastRowIndex: Math.min(DEFAULT_ROWS_TO_PROCESS, Math.max(apiRef.current.state.rows.dataRowIds.length, 0))\n    } : EMPTY_RANGE;\n  });\n  const lastRange = React.useRef(EMPTY_RANGE);\n  const updateRowSpanningState = React.useCallback(\n  // A reset needs to occur when:\n  // - The `unstable_rowSpanning` prop is updated (feature flag)\n  // - The filtering is applied\n  // - The sorting is applied\n  // - The `paginationModel` is updated\n  // - The rows are updated\n  function () {\n    let resetState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    if (!props.unstable_rowSpanning) {\n      if (apiRef.current.state.rowSpanning !== EMPTY_STATE) {\n        apiRef.current.setState(state => _extends({}, state, {\n          rowSpanning: EMPTY_STATE\n        }));\n      }\n      return;\n    }\n    if (range === null || !isRowContextInitialized(renderContext)) {\n      return;\n    }\n    if (resetState) {\n      processedRange.current = EMPTY_RANGE;\n    }\n    const rangeToProcess = getUnprocessedRange({\n      firstRowIndex: renderContext.firstRowIndex,\n      lastRowIndex: Math.min(renderContext.lastRowIndex, range.lastRowIndex + 1)\n    }, processedRange.current);\n    if (rangeToProcess === null) {\n      return;\n    }\n    const {\n      spannedCells,\n      hiddenCells,\n      hiddenCellOriginMap,\n      processedRange: newProcessedRange\n    } = computeRowSpanningState(apiRef, colDefs, visibleRows, range, rangeToProcess, resetState, processedRange.current);\n    processedRange.current = newProcessedRange;\n    const newSpannedCellsCount = Object.keys(spannedCells).length;\n    const newHiddenCellsCount = Object.keys(hiddenCells).length;\n    const currentSpannedCellsCount = Object.keys(apiRef.current.state.rowSpanning.spannedCells).length;\n    const currentHiddenCellsCount = Object.keys(apiRef.current.state.rowSpanning.hiddenCells).length;\n    const shouldUpdateState = resetState || newSpannedCellsCount !== currentSpannedCellsCount || newHiddenCellsCount !== currentHiddenCellsCount;\n    if (!shouldUpdateState) {\n      return;\n    }\n    apiRef.current.setState(state => {\n      return _extends({}, state, {\n        rowSpanning: {\n          spannedCells,\n          hiddenCells,\n          hiddenCellOriginMap\n        }\n      });\n    });\n  }, [apiRef, props.unstable_rowSpanning, range, renderContext, visibleRows, colDefs, processedRange]);\n  const prevRenderContext = React.useRef(renderContext);\n  const isFirstRender = React.useRef(true);\n  const shouldResetState = React.useRef(false);\n  const previousTree = React.useRef(tree);\n  React.useEffect(() => {\n    const firstRender = isFirstRender.current;\n    if (isFirstRender.current) {\n      isFirstRender.current = false;\n    }\n    if (tree !== previousTree.current) {\n      previousTree.current = tree;\n      updateRowSpanningState(true);\n      return;\n    }\n    if (range && lastRange.current && isRowRangeUpdated(range, lastRange.current)) {\n      lastRange.current = range;\n      shouldResetState.current = true;\n    }\n    if (!firstRender && prevRenderContext.current !== renderContext) {\n      if (isRowRangeUpdated(prevRenderContext.current, renderContext)) {\n        updateRowSpanningState(shouldResetState.current);\n        shouldResetState.current = false;\n      }\n      prevRenderContext.current = renderContext;\n      return;\n    }\n    updateRowSpanningState();\n  }, [updateRowSpanningState, renderContext, range, lastRange, tree]);\n};","map":{"version":3,"names":["_extends","React","useLazyRef","GRID_DETAIL_PANEL_TOGGLE_FIELD","gridVisibleColumnDefinitionsSelector","useGridVisibleRows","gridRenderContextSelector","useGridSelector","gridRowTreeSelector","getUnprocessedRange","isRowRangeUpdated","isRowContextInitialized","getCellValue","GRID_CHECKBOX_SELECTION_FIELD","EMPTY_STATE","spannedCells","hiddenCells","hiddenCellOriginMap","EMPTY_RANGE","firstRowIndex","lastRowIndex","skippedFields","Set","DEFAULT_ROWS_TO_PROCESS","computeRowSpanningState","apiRef","colDefs","visibleRows","range","rangeToProcess","resetState","processedRange","current","state","rowSpanning","forEach","colDef","has","field","index","_hiddenCells$row$id","row","id","cellValue","model","spannedRowId","spannedRowIndex","rowSpan","backwardsHiddenCells","prevIndex","prevRowEntry","currentRow","push","hiddenCellIndex","relativeIndex","Math","min","max","rowSpanningStateInitializer","props","unstable_rowSpanning","_state$filter$filterM","rowIds","rows","dataRowIds","orderedFields","columns","dataRowIdToModelLookup","columnsLookup","lookup","isFilteringPending","Boolean","filter","filterModel","items","length","quickFilterValues","map","useGridRowSpanning","renderContext","tree","Object","keys","lastRange","useRef","updateRowSpanningState","useCallback","arguments","undefined","setState","newProcessedRange","newSpannedCellsCount","newHiddenCellsCount","currentSpannedCellsCount","currentHiddenCellsCount","shouldUpdateState","prevRenderContext","isFirstRender","shouldResetState","previousTree","useEffect","firstRender"],"sources":["C:/Users/jpitt/VSCode/faustus-price-checker/web-ui/node_modules/@mui/x-data-grid/hooks/features/rows/useGridRowSpanning.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport useLazyRef from '@mui/utils/useLazyRef';\nimport { GRID_DETAIL_PANEL_TOGGLE_FIELD } from \"../../../internals/constants.js\";\nimport { gridVisibleColumnDefinitionsSelector } from \"../columns/gridColumnsSelector.js\";\nimport { useGridVisibleRows } from \"../../utils/useGridVisibleRows.js\";\nimport { gridRenderContextSelector } from \"../virtualization/gridVirtualizationSelectors.js\";\nimport { useGridSelector } from \"../../utils/useGridSelector.js\";\nimport { gridRowTreeSelector } from \"./gridRowsSelector.js\";\nimport { getUnprocessedRange, isRowRangeUpdated, isRowContextInitialized, getCellValue } from \"./gridRowSpanningUtils.js\";\nimport { GRID_CHECKBOX_SELECTION_FIELD } from \"../../../colDef/gridCheckboxSelectionColDef.js\";\nconst EMPTY_STATE = {\n  spannedCells: {},\n  hiddenCells: {},\n  hiddenCellOriginMap: {}\n};\nconst EMPTY_RANGE = {\n  firstRowIndex: 0,\n  lastRowIndex: 0\n};\nconst skippedFields = new Set([GRID_CHECKBOX_SELECTION_FIELD, '__reorder__', GRID_DETAIL_PANEL_TOGGLE_FIELD]);\n/**\n * Default number of rows to process during state initialization to avoid flickering.\n * Number `20` is arbitrarily chosen to be large enough to cover most of the cases without\n * compromising performance.\n */\nconst DEFAULT_ROWS_TO_PROCESS = 20;\nconst computeRowSpanningState = (apiRef, colDefs, visibleRows, range, rangeToProcess, resetState, processedRange) => {\n  const spannedCells = resetState ? {} : _extends({}, apiRef.current.state.rowSpanning.spannedCells);\n  const hiddenCells = resetState ? {} : _extends({}, apiRef.current.state.rowSpanning.hiddenCells);\n  const hiddenCellOriginMap = resetState ? {} : _extends({}, apiRef.current.state.rowSpanning.hiddenCellOriginMap);\n  if (resetState) {\n    processedRange = EMPTY_RANGE;\n  }\n  colDefs.forEach(colDef => {\n    if (skippedFields.has(colDef.field)) {\n      return;\n    }\n    for (let index = rangeToProcess.firstRowIndex; index < rangeToProcess.lastRowIndex; index += 1) {\n      const row = visibleRows[index];\n      if (hiddenCells[row.id]?.[colDef.field]) {\n        continue;\n      }\n      const cellValue = getCellValue(row.model, colDef, apiRef);\n      if (cellValue == null) {\n        continue;\n      }\n      let spannedRowId = row.id;\n      let spannedRowIndex = index;\n      let rowSpan = 0;\n\n      // For first index, also scan in the previous rows to handle the reset state case e.g by sorting\n      const backwardsHiddenCells = [];\n      if (index === rangeToProcess.firstRowIndex) {\n        let prevIndex = index - 1;\n        const prevRowEntry = visibleRows[prevIndex];\n        while (prevIndex >= range.firstRowIndex && getCellValue(prevRowEntry.model, colDef, apiRef) === cellValue) {\n          const currentRow = visibleRows[prevIndex + 1];\n          if (hiddenCells[currentRow.id]) {\n            hiddenCells[currentRow.id][colDef.field] = true;\n          } else {\n            hiddenCells[currentRow.id] = {\n              [colDef.field]: true\n            };\n          }\n          backwardsHiddenCells.push(index);\n          rowSpan += 1;\n          spannedRowId = prevRowEntry.id;\n          spannedRowIndex = prevIndex;\n          prevIndex -= 1;\n        }\n      }\n      backwardsHiddenCells.forEach(hiddenCellIndex => {\n        if (hiddenCellOriginMap[hiddenCellIndex]) {\n          hiddenCellOriginMap[hiddenCellIndex][colDef.field] = spannedRowIndex;\n        } else {\n          hiddenCellOriginMap[hiddenCellIndex] = {\n            [colDef.field]: spannedRowIndex\n          };\n        }\n      });\n\n      // Scan the next rows\n      let relativeIndex = index + 1;\n      while (relativeIndex <= range.lastRowIndex && visibleRows[relativeIndex] && getCellValue(visibleRows[relativeIndex].model, colDef, apiRef) === cellValue) {\n        const currentRow = visibleRows[relativeIndex];\n        if (hiddenCells[currentRow.id]) {\n          hiddenCells[currentRow.id][colDef.field] = true;\n        } else {\n          hiddenCells[currentRow.id] = {\n            [colDef.field]: true\n          };\n        }\n        if (hiddenCellOriginMap[relativeIndex]) {\n          hiddenCellOriginMap[relativeIndex][colDef.field] = spannedRowIndex;\n        } else {\n          hiddenCellOriginMap[relativeIndex] = {\n            [colDef.field]: spannedRowIndex\n          };\n        }\n        relativeIndex += 1;\n        rowSpan += 1;\n      }\n      if (rowSpan > 0) {\n        if (spannedCells[spannedRowId]) {\n          spannedCells[spannedRowId][colDef.field] = rowSpan + 1;\n        } else {\n          spannedCells[spannedRowId] = {\n            [colDef.field]: rowSpan + 1\n          };\n        }\n      }\n    }\n    processedRange = {\n      firstRowIndex: Math.min(processedRange.firstRowIndex, rangeToProcess.firstRowIndex),\n      lastRowIndex: Math.max(processedRange.lastRowIndex, rangeToProcess.lastRowIndex)\n    };\n  });\n  return {\n    spannedCells,\n    hiddenCells,\n    hiddenCellOriginMap,\n    processedRange\n  };\n};\n\n/**\n * @requires columnsStateInitializer (method) - should be initialized before\n * @requires rowsStateInitializer (method) - should be initialized before\n * @requires filterStateInitializer (method) - should be initialized before\n */\nexport const rowSpanningStateInitializer = (state, props, apiRef) => {\n  if (props.unstable_rowSpanning) {\n    const rowIds = state.rows.dataRowIds || [];\n    const orderedFields = state.columns.orderedFields || [];\n    const dataRowIdToModelLookup = state.rows.dataRowIdToModelLookup;\n    const columnsLookup = state.columns.lookup;\n    const isFilteringPending = Boolean(state.filter.filterModel.items.length) || Boolean(state.filter.filterModel.quickFilterValues?.length);\n    if (!rowIds.length || !orderedFields.length || !dataRowIdToModelLookup || !columnsLookup || isFilteringPending) {\n      return _extends({}, state, {\n        rowSpanning: EMPTY_STATE\n      });\n    }\n    const rangeToProcess = {\n      firstRowIndex: 0,\n      lastRowIndex: Math.min(DEFAULT_ROWS_TO_PROCESS, Math.max(rowIds.length, 0))\n    };\n    const rows = rowIds.map(id => ({\n      id,\n      model: dataRowIdToModelLookup[id]\n    }));\n    const colDefs = orderedFields.map(field => columnsLookup[field]);\n    const {\n      spannedCells,\n      hiddenCells,\n      hiddenCellOriginMap\n    } = computeRowSpanningState(apiRef, colDefs, rows, rangeToProcess, rangeToProcess, true, EMPTY_RANGE);\n    return _extends({}, state, {\n      rowSpanning: {\n        spannedCells,\n        hiddenCells,\n        hiddenCellOriginMap\n      }\n    });\n  }\n  return _extends({}, state, {\n    rowSpanning: EMPTY_STATE\n  });\n};\nexport const useGridRowSpanning = (apiRef, props) => {\n  const {\n    range,\n    rows: visibleRows\n  } = useGridVisibleRows(apiRef, props);\n  const renderContext = useGridSelector(apiRef, gridRenderContextSelector);\n  const colDefs = useGridSelector(apiRef, gridVisibleColumnDefinitionsSelector);\n  const tree = useGridSelector(apiRef, gridRowTreeSelector);\n  const processedRange = useLazyRef(() => {\n    return Object.keys(apiRef.current.state.rowSpanning.spannedCells).length > 0 ? {\n      firstRowIndex: 0,\n      lastRowIndex: Math.min(DEFAULT_ROWS_TO_PROCESS, Math.max(apiRef.current.state.rows.dataRowIds.length, 0))\n    } : EMPTY_RANGE;\n  });\n  const lastRange = React.useRef(EMPTY_RANGE);\n  const updateRowSpanningState = React.useCallback(\n  // A reset needs to occur when:\n  // - The `unstable_rowSpanning` prop is updated (feature flag)\n  // - The filtering is applied\n  // - The sorting is applied\n  // - The `paginationModel` is updated\n  // - The rows are updated\n  (resetState = true) => {\n    if (!props.unstable_rowSpanning) {\n      if (apiRef.current.state.rowSpanning !== EMPTY_STATE) {\n        apiRef.current.setState(state => _extends({}, state, {\n          rowSpanning: EMPTY_STATE\n        }));\n      }\n      return;\n    }\n    if (range === null || !isRowContextInitialized(renderContext)) {\n      return;\n    }\n    if (resetState) {\n      processedRange.current = EMPTY_RANGE;\n    }\n    const rangeToProcess = getUnprocessedRange({\n      firstRowIndex: renderContext.firstRowIndex,\n      lastRowIndex: Math.min(renderContext.lastRowIndex, range.lastRowIndex + 1)\n    }, processedRange.current);\n    if (rangeToProcess === null) {\n      return;\n    }\n    const {\n      spannedCells,\n      hiddenCells,\n      hiddenCellOriginMap,\n      processedRange: newProcessedRange\n    } = computeRowSpanningState(apiRef, colDefs, visibleRows, range, rangeToProcess, resetState, processedRange.current);\n    processedRange.current = newProcessedRange;\n    const newSpannedCellsCount = Object.keys(spannedCells).length;\n    const newHiddenCellsCount = Object.keys(hiddenCells).length;\n    const currentSpannedCellsCount = Object.keys(apiRef.current.state.rowSpanning.spannedCells).length;\n    const currentHiddenCellsCount = Object.keys(apiRef.current.state.rowSpanning.hiddenCells).length;\n    const shouldUpdateState = resetState || newSpannedCellsCount !== currentSpannedCellsCount || newHiddenCellsCount !== currentHiddenCellsCount;\n    if (!shouldUpdateState) {\n      return;\n    }\n    apiRef.current.setState(state => {\n      return _extends({}, state, {\n        rowSpanning: {\n          spannedCells,\n          hiddenCells,\n          hiddenCellOriginMap\n        }\n      });\n    });\n  }, [apiRef, props.unstable_rowSpanning, range, renderContext, visibleRows, colDefs, processedRange]);\n  const prevRenderContext = React.useRef(renderContext);\n  const isFirstRender = React.useRef(true);\n  const shouldResetState = React.useRef(false);\n  const previousTree = React.useRef(tree);\n  React.useEffect(() => {\n    const firstRender = isFirstRender.current;\n    if (isFirstRender.current) {\n      isFirstRender.current = false;\n    }\n    if (tree !== previousTree.current) {\n      previousTree.current = tree;\n      updateRowSpanningState(true);\n      return;\n    }\n    if (range && lastRange.current && isRowRangeUpdated(range, lastRange.current)) {\n      lastRange.current = range;\n      shouldResetState.current = true;\n    }\n    if (!firstRender && prevRenderContext.current !== renderContext) {\n      if (isRowRangeUpdated(prevRenderContext.current, renderContext)) {\n        updateRowSpanningState(shouldResetState.current);\n        shouldResetState.current = false;\n      }\n      prevRenderContext.current = renderContext;\n      return;\n    }\n    updateRowSpanningState();\n  }, [updateRowSpanningState, renderContext, range, lastRange, tree]);\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}