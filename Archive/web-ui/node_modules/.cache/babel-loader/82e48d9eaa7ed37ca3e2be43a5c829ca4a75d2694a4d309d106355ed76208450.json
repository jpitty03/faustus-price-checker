{"ast":null,"code":"import { GridSignature } from \"../../utils/useGridApiEventHandler.js\";\nimport { GRID_ROOT_GROUP_ID } from \"../rows/gridRowsUtils.js\";\nimport { gridFilteredRowsLookupSelector } from \"../filter/gridFilterSelector.js\";\nimport { gridSortedRowIdsSelector } from \"../sorting/gridSortingSelector.js\";\nimport { selectedIdsLookupSelector } from \"./gridRowSelectionSelector.js\";\nimport { gridRowTreeSelector } from \"../rows/gridRowsSelector.js\";\nimport { createSelector } from \"../../../utils/createSelector.js\";\nexport const ROW_SELECTION_PROPAGATION_DEFAULT = {\n  parents: false,\n  descendants: false\n};\nfunction getGridRowGroupSelectableDescendants(apiRef, groupId) {\n  const rowTree = gridRowTreeSelector(apiRef);\n  const sortedRowIds = gridSortedRowIdsSelector(apiRef);\n  const filteredRowsLookup = gridFilteredRowsLookupSelector(apiRef);\n  const groupNode = rowTree[groupId];\n  if (!groupNode || groupNode.type !== 'group') {\n    return [];\n  }\n  const descendants = [];\n  const startIndex = sortedRowIds.findIndex(id => id === groupId) + 1;\n  for (let index = startIndex; index < sortedRowIds.length && ((_rowTree$sortedRowIds = rowTree[sortedRowIds[index]]) === null || _rowTree$sortedRowIds === void 0 ? void 0 : _rowTree$sortedRowIds.depth) > groupNode.depth; index += 1) {\n    var _rowTree$sortedRowIds;\n    const id = sortedRowIds[index];\n    if (filteredRowsLookup[id] !== false && apiRef.current.isRowSelectable(id)) {\n      descendants.push(id);\n    }\n  }\n  return descendants;\n}\n\n// TODO v8: Use `createSelectorV8`\nexport function getCheckboxPropsSelector(groupId, autoSelectParents) {\n  return createSelector(gridRowTreeSelector, gridSortedRowIdsSelector, gridFilteredRowsLookupSelector, selectedIdsLookupSelector, (rowTree, sortedRowIds, filteredRowsLookup, rowSelectionLookup) => {\n    const groupNode = rowTree[groupId];\n    if (!groupNode || groupNode.type !== 'group') {\n      return {\n        isIndeterminate: false,\n        isChecked: rowSelectionLookup[groupId] === groupId\n      };\n    }\n    if (rowSelectionLookup[groupId] === groupId) {\n      return {\n        isIndeterminate: false,\n        isChecked: true\n      };\n    }\n    let selectableDescendantsCount = 0;\n    let selectedDescendantsCount = 0;\n    const startIndex = sortedRowIds.findIndex(id => id === groupId) + 1;\n    for (let index = startIndex; index < sortedRowIds.length && ((_rowTree$sortedRowIds2 = rowTree[sortedRowIds[index]]) === null || _rowTree$sortedRowIds2 === void 0 ? void 0 : _rowTree$sortedRowIds2.depth) > groupNode.depth; index += 1) {\n      var _rowTree$sortedRowIds2;\n      const id = sortedRowIds[index];\n      if (filteredRowsLookup[id] !== false) {\n        selectableDescendantsCount += 1;\n        if (rowSelectionLookup[id] !== undefined) {\n          selectedDescendantsCount += 1;\n        }\n      }\n    }\n    return {\n      isIndeterminate: selectedDescendantsCount > 0 && (selectedDescendantsCount < selectableDescendantsCount || rowSelectionLookup[groupId] === undefined),\n      isChecked: autoSelectParents ? selectedDescendantsCount > 0 : rowSelectionLookup[groupId] === groupId\n    };\n  });\n}\nexport function isMultipleRowSelectionEnabled(props) {\n  if (props.signature === GridSignature.DataGrid) {\n    // DataGrid Community has multiple row selection enabled only if checkbox selection is enabled.\n    return props.checkboxSelection && props.disableMultipleRowSelection !== true;\n  }\n  return !props.disableMultipleRowSelection;\n}\nconst getRowNodeParents = (tree, id) => {\n  const parents = [];\n  let parent = id;\n  while (parent != null && parent !== GRID_ROOT_GROUP_ID) {\n    const node = tree[parent];\n    if (!node) {\n      return parents;\n    }\n    parents.push(parent);\n    parent = node.parent;\n  }\n  return parents;\n};\nconst getFilteredRowNodeSiblings = (tree, filteredRows, id) => {\n  const node = tree[id];\n  if (!node) {\n    return [];\n  }\n  const parent = node.parent;\n  if (parent == null) {\n    return [];\n  }\n  const parentNode = tree[parent];\n  return parentNode.children.filter(childId => childId !== id && filteredRows[childId]);\n};\nexport const findRowsToSelect = (apiRef, tree, selectedRow, autoSelectDescendants, autoSelectParents, addRow) => {\n  const filteredRows = gridFilteredRowsLookupSelector(apiRef);\n  const selectedIdsLookup = selectedIdsLookupSelector(apiRef);\n  const selectedDescendants = new Set([]);\n  if (!autoSelectDescendants && !autoSelectParents) {\n    return;\n  }\n  if (autoSelectDescendants) {\n    const rowNode = tree[selectedRow];\n    if ((rowNode === null || rowNode === void 0 ? void 0 : rowNode.type) === 'group') {\n      const descendants = getGridRowGroupSelectableDescendants(apiRef, selectedRow);\n      descendants.forEach(rowId => {\n        addRow(rowId);\n        selectedDescendants.add(rowId);\n      });\n    }\n  }\n  if (autoSelectParents) {\n    const checkAllDescendantsSelected = rowId => {\n      if (selectedIdsLookup[rowId] !== rowId && !selectedDescendants.has(rowId)) {\n        return false;\n      }\n      const node = tree[rowId];\n      if ((node === null || node === void 0 ? void 0 : node.type) !== 'group') {\n        return true;\n      }\n      return node.children.every(checkAllDescendantsSelected);\n    };\n    const traverseParents = rowId => {\n      const siblings = getFilteredRowNodeSiblings(tree, filteredRows, rowId);\n      if (siblings.length === 0 || siblings.every(checkAllDescendantsSelected)) {\n        const rowNode = tree[rowId];\n        const parent = rowNode.parent;\n        if (parent != null && parent !== GRID_ROOT_GROUP_ID && apiRef.current.isRowSelectable(parent)) {\n          addRow(parent);\n          selectedDescendants.add(parent);\n          traverseParents(parent);\n        }\n      }\n    };\n    traverseParents(selectedRow);\n  }\n};\nexport const findRowsToDeselect = (apiRef, tree, deselectedRow, autoSelectDescendants, autoSelectParents, removeRow) => {\n  const selectedIdsLookup = selectedIdsLookupSelector(apiRef);\n  if (!autoSelectParents && !autoSelectDescendants) {\n    return;\n  }\n  if (autoSelectParents) {\n    const allParents = getRowNodeParents(tree, deselectedRow);\n    allParents.forEach(parent => {\n      const isSelected = selectedIdsLookup[parent] === parent;\n      if (isSelected) {\n        removeRow(parent);\n      }\n    });\n  }\n  if (autoSelectDescendants) {\n    const rowNode = tree[deselectedRow];\n    if ((rowNode === null || rowNode === void 0 ? void 0 : rowNode.type) === 'group') {\n      const descendants = getGridRowGroupSelectableDescendants(apiRef, deselectedRow);\n      descendants.forEach(descendant => {\n        removeRow(descendant);\n      });\n    }\n  }\n};","map":{"version":3,"names":["GridSignature","GRID_ROOT_GROUP_ID","gridFilteredRowsLookupSelector","gridSortedRowIdsSelector","selectedIdsLookupSelector","gridRowTreeSelector","createSelector","ROW_SELECTION_PROPAGATION_DEFAULT","parents","descendants","getGridRowGroupSelectableDescendants","apiRef","groupId","rowTree","sortedRowIds","filteredRowsLookup","groupNode","type","startIndex","findIndex","id","index","length","_rowTree$sortedRowIds","depth","current","isRowSelectable","push","getCheckboxPropsSelector","autoSelectParents","rowSelectionLookup","isIndeterminate","isChecked","selectableDescendantsCount","selectedDescendantsCount","_rowTree$sortedRowIds2","undefined","isMultipleRowSelectionEnabled","props","signature","DataGrid","checkboxSelection","disableMultipleRowSelection","getRowNodeParents","tree","parent","node","getFilteredRowNodeSiblings","filteredRows","parentNode","children","filter","childId","findRowsToSelect","selectedRow","autoSelectDescendants","addRow","selectedIdsLookup","selectedDescendants","Set","rowNode","forEach","rowId","add","checkAllDescendantsSelected","has","every","traverseParents","siblings","findRowsToDeselect","deselectedRow","removeRow","allParents","isSelected","descendant"],"sources":["C:/Users/jpitt/VSCode/faustus-price-checker/web-ui/node_modules/@mui/x-data-grid/hooks/features/rowSelection/utils.js"],"sourcesContent":["import { GridSignature } from \"../../utils/useGridApiEventHandler.js\";\nimport { GRID_ROOT_GROUP_ID } from \"../rows/gridRowsUtils.js\";\nimport { gridFilteredRowsLookupSelector } from \"../filter/gridFilterSelector.js\";\nimport { gridSortedRowIdsSelector } from \"../sorting/gridSortingSelector.js\";\nimport { selectedIdsLookupSelector } from \"./gridRowSelectionSelector.js\";\nimport { gridRowTreeSelector } from \"../rows/gridRowsSelector.js\";\nimport { createSelector } from \"../../../utils/createSelector.js\";\nexport const ROW_SELECTION_PROPAGATION_DEFAULT = {\n  parents: false,\n  descendants: false\n};\nfunction getGridRowGroupSelectableDescendants(apiRef, groupId) {\n  const rowTree = gridRowTreeSelector(apiRef);\n  const sortedRowIds = gridSortedRowIdsSelector(apiRef);\n  const filteredRowsLookup = gridFilteredRowsLookupSelector(apiRef);\n  const groupNode = rowTree[groupId];\n  if (!groupNode || groupNode.type !== 'group') {\n    return [];\n  }\n  const descendants = [];\n  const startIndex = sortedRowIds.findIndex(id => id === groupId) + 1;\n  for (let index = startIndex; index < sortedRowIds.length && rowTree[sortedRowIds[index]]?.depth > groupNode.depth; index += 1) {\n    const id = sortedRowIds[index];\n    if (filteredRowsLookup[id] !== false && apiRef.current.isRowSelectable(id)) {\n      descendants.push(id);\n    }\n  }\n  return descendants;\n}\n\n// TODO v8: Use `createSelectorV8`\nexport function getCheckboxPropsSelector(groupId, autoSelectParents) {\n  return createSelector(gridRowTreeSelector, gridSortedRowIdsSelector, gridFilteredRowsLookupSelector, selectedIdsLookupSelector, (rowTree, sortedRowIds, filteredRowsLookup, rowSelectionLookup) => {\n    const groupNode = rowTree[groupId];\n    if (!groupNode || groupNode.type !== 'group') {\n      return {\n        isIndeterminate: false,\n        isChecked: rowSelectionLookup[groupId] === groupId\n      };\n    }\n    if (rowSelectionLookup[groupId] === groupId) {\n      return {\n        isIndeterminate: false,\n        isChecked: true\n      };\n    }\n    let selectableDescendantsCount = 0;\n    let selectedDescendantsCount = 0;\n    const startIndex = sortedRowIds.findIndex(id => id === groupId) + 1;\n    for (let index = startIndex; index < sortedRowIds.length && rowTree[sortedRowIds[index]]?.depth > groupNode.depth; index += 1) {\n      const id = sortedRowIds[index];\n      if (filteredRowsLookup[id] !== false) {\n        selectableDescendantsCount += 1;\n        if (rowSelectionLookup[id] !== undefined) {\n          selectedDescendantsCount += 1;\n        }\n      }\n    }\n    return {\n      isIndeterminate: selectedDescendantsCount > 0 && (selectedDescendantsCount < selectableDescendantsCount || rowSelectionLookup[groupId] === undefined),\n      isChecked: autoSelectParents ? selectedDescendantsCount > 0 : rowSelectionLookup[groupId] === groupId\n    };\n  });\n}\nexport function isMultipleRowSelectionEnabled(props) {\n  if (props.signature === GridSignature.DataGrid) {\n    // DataGrid Community has multiple row selection enabled only if checkbox selection is enabled.\n    return props.checkboxSelection && props.disableMultipleRowSelection !== true;\n  }\n  return !props.disableMultipleRowSelection;\n}\nconst getRowNodeParents = (tree, id) => {\n  const parents = [];\n  let parent = id;\n  while (parent != null && parent !== GRID_ROOT_GROUP_ID) {\n    const node = tree[parent];\n    if (!node) {\n      return parents;\n    }\n    parents.push(parent);\n    parent = node.parent;\n  }\n  return parents;\n};\nconst getFilteredRowNodeSiblings = (tree, filteredRows, id) => {\n  const node = tree[id];\n  if (!node) {\n    return [];\n  }\n  const parent = node.parent;\n  if (parent == null) {\n    return [];\n  }\n  const parentNode = tree[parent];\n  return parentNode.children.filter(childId => childId !== id && filteredRows[childId]);\n};\nexport const findRowsToSelect = (apiRef, tree, selectedRow, autoSelectDescendants, autoSelectParents, addRow) => {\n  const filteredRows = gridFilteredRowsLookupSelector(apiRef);\n  const selectedIdsLookup = selectedIdsLookupSelector(apiRef);\n  const selectedDescendants = new Set([]);\n  if (!autoSelectDescendants && !autoSelectParents) {\n    return;\n  }\n  if (autoSelectDescendants) {\n    const rowNode = tree[selectedRow];\n    if (rowNode?.type === 'group') {\n      const descendants = getGridRowGroupSelectableDescendants(apiRef, selectedRow);\n      descendants.forEach(rowId => {\n        addRow(rowId);\n        selectedDescendants.add(rowId);\n      });\n    }\n  }\n  if (autoSelectParents) {\n    const checkAllDescendantsSelected = rowId => {\n      if (selectedIdsLookup[rowId] !== rowId && !selectedDescendants.has(rowId)) {\n        return false;\n      }\n      const node = tree[rowId];\n      if (node?.type !== 'group') {\n        return true;\n      }\n      return node.children.every(checkAllDescendantsSelected);\n    };\n    const traverseParents = rowId => {\n      const siblings = getFilteredRowNodeSiblings(tree, filteredRows, rowId);\n      if (siblings.length === 0 || siblings.every(checkAllDescendantsSelected)) {\n        const rowNode = tree[rowId];\n        const parent = rowNode.parent;\n        if (parent != null && parent !== GRID_ROOT_GROUP_ID && apiRef.current.isRowSelectable(parent)) {\n          addRow(parent);\n          selectedDescendants.add(parent);\n          traverseParents(parent);\n        }\n      }\n    };\n    traverseParents(selectedRow);\n  }\n};\nexport const findRowsToDeselect = (apiRef, tree, deselectedRow, autoSelectDescendants, autoSelectParents, removeRow) => {\n  const selectedIdsLookup = selectedIdsLookupSelector(apiRef);\n  if (!autoSelectParents && !autoSelectDescendants) {\n    return;\n  }\n  if (autoSelectParents) {\n    const allParents = getRowNodeParents(tree, deselectedRow);\n    allParents.forEach(parent => {\n      const isSelected = selectedIdsLookup[parent] === parent;\n      if (isSelected) {\n        removeRow(parent);\n      }\n    });\n  }\n  if (autoSelectDescendants) {\n    const rowNode = tree[deselectedRow];\n    if (rowNode?.type === 'group') {\n      const descendants = getGridRowGroupSelectableDescendants(apiRef, deselectedRow);\n      descendants.forEach(descendant => {\n        removeRow(descendant);\n      });\n    }\n  }\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}